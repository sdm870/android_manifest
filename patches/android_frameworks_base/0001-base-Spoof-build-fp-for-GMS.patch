From 246ea3f60dca537dd901a8e184ebdf103347140e Mon Sep 17 00:00:00 2001
From: Danny Lin <danny@kdrag0n.dev>
Date: Sat, 16 Oct 2021 09:35:03 +0200
Subject: [PATCH 1/2] base: Spoof build fp for GMS

SafetyNet's CTS profile attestation checks whether Build.FINGERPRINT
matches that of the device's stock OS, which has passed CTS testing.
Spoof the fingerprint for Google Play Services to help pass SafetyNet.

We used to set the real system build fingerprint to the stock one, but
Android relies on each build having a unique fingerprint in order to
clear the correct caches and update persistent state for system changes.
On devices that no longer receive updates from the OEM, the build
fingerprint never changes and Android doesn't account for updates
correctly, which causes issues when updating without wiping data.
Only spoofing the fingerprint for Google Play Services fixes this issue.

Corresponding vendor commit:
"Only use stock build fingerprint for Google Play Services"

keystore: Block key attestation for SafetyNet

SafetyNet (part of Google Play Services) opportunistically uses
hardware-backed key attestation via KeyStore as a strong integrity
check. This causes SafetyNet to fail on custom ROMs because the verified
boot key and bootloader unlock state can be detected from attestation
certificates.

As a workaround, we can take advantage of the fact that SafetyNet's
usage of key attestation is opportunistic (i.e. falls back to basic
integrity checks if it fails) and prevent it from getting the
attestation certificate chain from KeyStore. This is done by checking
the stack for DroidGuard, which is the codename for SafetyNet, and
pretending that the device doesn't support key attestation.

Key attestation has only been blocked for SafetyNet specifically, as
Google Play Services and other apps have many valid reasons to use it.
For example, it appears to be involved in Google's mobile security key
ferature.

Change-Id: I5661ef56c3f6e468bcf35495c1bebf770cac1617
---
 core/java/android/app/Instrumentation.java    |  6 ++
 .../internal/util/SpoofFingerprint.java       | 91 +++++++++++++++++++
 .../keystore2/AndroidKeyStoreSpi.java         |  4 +
 3 files changed, 101 insertions(+)
 create mode 100644 core/java/com/android/internal/util/SpoofFingerprint.java

diff --git a/core/java/android/app/Instrumentation.java b/core/java/android/app/Instrumentation.java
index fd6fa57b9e8d..283f48821139 100644
--- a/core/java/android/app/Instrumentation.java
+++ b/core/java/android/app/Instrumentation.java
@@ -64,6 +64,8 @@ import java.util.ArrayList;
 import java.util.List;
 import java.util.concurrent.TimeoutException;
 
+import com.android.internal.util.SpoofFingerprint;
+
 /**
  * Base class for implementing application instrumentation code.  When running
  * with instrumentation turned on, this class will be instantiated for you
@@ -1188,6 +1190,8 @@ public class Instrumentation {
         Application app = getFactory(context.getPackageName())
                 .instantiateApplication(cl, className);
         app.attach(context);
+        String packageName = app.getPackageName();
+        SpoofFingerprint.setProps(packageName);
         return app;
     }
     
@@ -1205,6 +1209,8 @@ public class Instrumentation {
             ClassNotFoundException {
         Application app = (Application)clazz.newInstance();
         app.attach(context);
+        String packageName = app.getPackageName();
+        SpoofFingerprint.setProps(packageName);
         return app;
     }
 
diff --git a/core/java/com/android/internal/util/SpoofFingerprint.java b/core/java/com/android/internal/util/SpoofFingerprint.java
new file mode 100644
index 000000000000..9774b5068def
--- /dev/null
+++ b/core/java/com/android/internal/util/SpoofFingerprint.java
@@ -0,0 +1,91 @@
+/*
+ * Copyright (C) 2022 The LineageOS Project
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ * http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package com.android.internal.util;
+
+import android.os.Build;
+import android.util.Log;
+
+import java.util.Arrays;
+import java.util.ArrayList;
+import java.lang.reflect.Field;
+import java.util.HashMap;
+import java.util.Map;
+
+public class SpoofFingerprint {
+
+    private static final String TAG = SpoofFingerprint.class.getSimpleName();
+    private static final boolean DEBUG = false;
+
+    private static volatile boolean sIsGms = false;
+    public static final String PACKAGE_GMS = "com.google.android.gms";
+    public static final String PACKAGE_VENDING = "com.android.vending";
+
+    private static final Map<String, Object> propsToChange;
+    private static final Map<String, ArrayList<String>> propsToKeep;
+
+    static {
+        propsToKeep = new HashMap<>();
+        propsToKeep.put("com.google.android.settings.intelligence", new ArrayList<String>(Arrays.asList("FINGERPRINT")));
+        propsToChange = new HashMap<>();
+        propsToChange.put("FINGERPRINT", "Xiaomi/polaris/polaris:8.0.0/OPR1.170623.032/V9.5.19.0.ODGMIFA:user/release-keys");
+    }
+
+    public static void setProps(String packageName) {
+        if (packageName == null){
+            return;
+        }
+        if (packageName.equals(PACKAGE_GMS)) {
+            sIsGms = true;
+        }
+        if (packageName.equals(PACKAGE_GMS) || packageName.equals(PACKAGE_VENDING)){
+            if (DEBUG) Log.d(TAG, "Defining props for: " + packageName);
+            for (Map.Entry<String, Object> prop : propsToChange.entrySet()) {
+                String key = prop.getKey();
+                Object value = prop.getValue();
+                if (propsToKeep.containsKey(packageName) && propsToKeep.get(packageName).contains(key)){
+                    if (DEBUG) Log.d(TAG, "Not defining " + key + " prop for: " + packageName);
+                    continue;
+                }
+                if (DEBUG) Log.d(TAG, "Defining " + key + " prop for: " + packageName);
+                setPropValue(key, value);
+            }
+        }
+    }
+
+    private static void setPropValue(String key, Object value){
+        try {
+            if (DEBUG) Log.d(TAG, "Defining prop " + key + " to " + value.toString());
+            Field field = Build.class.getDeclaredField(key);
+            field.setAccessible(true);
+            field.set(null, value);
+            field.setAccessible(false);
+        } catch (NoSuchFieldException | IllegalAccessException e) {
+            Log.e(TAG, "Failed to set prop " + key, e);
+        }
+    }
+
+    private static boolean isCallerSafetyNet() {
+        return Arrays.stream(Thread.currentThread().getStackTrace())
+                .anyMatch(elem -> elem.getClassName().contains("DroidGuard"));
+    }
+
+    public static void onEngineGetCertificateChain() {
+        // Check stack for SafetyNet
+        if (sIsGms && isCallerSafetyNet()) {
+            throw new UnsupportedOperationException();
+        }
+    }
+}
diff --git a/keystore/java/android/security/keystore2/AndroidKeyStoreSpi.java b/keystore/java/android/security/keystore2/AndroidKeyStoreSpi.java
index 33411e1ec5b9..b9a71844960f 100644
--- a/keystore/java/android/security/keystore2/AndroidKeyStoreSpi.java
+++ b/keystore/java/android/security/keystore2/AndroidKeyStoreSpi.java
@@ -77,6 +77,8 @@ import java.util.Set;
 
 import javax.crypto.SecretKey;
 
+import com.android.internal.util.SpoofFingerprint;
+
 /**
  * A java.security.KeyStore interface for the Android KeyStore. An instance of
  * it can be created via the {@link java.security.KeyStore#getInstance(String)
@@ -164,6 +166,8 @@ public class AndroidKeyStoreSpi extends KeyStoreSpi {
 
     @Override
     public Certificate[] engineGetCertificateChain(String alias) {
+        SpoofFingerprint.onEngineGetCertificateChain();
+
         KeyEntryResponse response = getKeyMetadata(alias);
 
         if (response == null || response.metadata.certificate == null) {
-- 
2.25.1

